
		Xvisor Design Overview

This is document gives an overview of the xvisor virtualization design.
It gives very important insight required for writing architecture support
for Xvisor. 


	 	Chapter 1: Modeling Virtual Machines

A virtual machine (VM) is a software emulation/simulation of a physical machine
(i.e. a computer system) that can executes programs or operating systems.

Virtual machines are separated into two major categories (based on their use): 
  * System Virtual Machine: A system virtual machine provides a complete system
    platform which supports the execution of a complete operating system (OS). 
  * Process Virtual Machine: A process virtual machine is designed to run a 
    single program, which means that it supports a single process. 

An essential characteristic of a virtual machine is that the software running 
inside is limited to the resources and abstractions provided by the virtual 
machineâ€”it cannot break out of its virtual world.

(Note: Above text has been adapted from Wikipedia page on "Virtual Machine")

Xvisor is a hardware assisted system virtualization software (i.e. implements
system virtual machine with hardware acceleration) running directly on a host
machine (i.e. physical machine/hardware). In short, we can say that Xvisor 
is a Native (or Type-1) Hypervisor (or Virtual Machine Monitor).

We refer to system virtual machine instances as "Guest" instances and CPUs of 
system virtual machines as "VCPU" instances. We refer to VCPU belonging to a 
Guest as "Normal VCPU" and VCPU not belonging to any guest as "Orphan VCPU".
Xvisor creates Orphan VCPUs for various background processing and running 
managment daemons. 

Any modern CPU architecure has atleast two priviledge modes: User Mode, and
Superviosr Mode. The User Mode has lowest priviledge and Supervisor Mode has
highest priviledge. Xvisor runs all Normal VCPUs in User Mode and all Orphan
VCPUs in Supervisor Mode (Note: Architecture specific code has to treat Normal
and Orphan VCPUs differently). Just like any OS, the VCPU context in Xvisor
has an architecture dependent part and an architecture independent part. 

The architecture dependent part of VCPU context consist of:
  1. User Registers: Registers which are updated by processor in user mode 
     (or unprivileged mode) only. This registers are usually general purpose 
     registers and status flags which are automatically updated by processor
     (e.g. comparision flags, overflow flag, zero flag, etc).
  2. Super Registers: Registers which are updated by processor in supervisor 
     mode (or privileged mode) only. Whenever VCPU tries to read/write such an
     register is updated we get an exception and we can return/update its 
     virtual value. In most of the cases there are also some additional data 
     structures (like MMU context, shadow TLB, shadow page table, ... etc) 
     in the super registers.
(Note: For Orphan VCPUs only User Registers are important)

The architecture independent part of VCPU context consist of:
  1. Unique VCPU number
  2. Unique VCPU Name (Only important for Orphan VCPUs)
  3. Pointer to VCPU Device Tree Node (Not available for Orphan VCPUs)
  4. Scheduling information (e.g. tick callback function, pending ticks, etc)
  5. Virtual interrupt managment information

In addtion to VCPUs, a Guest also has "Guest Address Space". The Guest Address
Space contains a set of "Guest Regions". Each Guest Region has a unique Guest 
Physical Address (i.e. Physical address at which region is accessible to Guest 
VCPUs) and Physical Size (i.e. Size of Guest Region). Further a Guest Region 
can be one of the two types:
  * Real Guest Region: A Real Guest Region gives direct access to a Host 
    Machine Device/Memory (e.g. RAM, UART, etc). It has to be mapped to a
    Host Physical Address (i.e. Physical address in Host Machine).
  * Virtual Guest Region: A Virtual Guest Region gives access to an emulated
    device (e.g. emulated PIC, emulated Timer, etc). This type of region is
    typically linked with an emulated device. The architecture specific code 
    is responsible for redirecting virtual guest region read/write access to
    the Xvisor device emulation framework. 

The figure below gives a clear picture of the System Virtual Machine Model 
implemented by Xvisor.

----------------------------    ----------------------------    --------------
|          Guest_0         |    |          Guest_M         |    |            |
|--------------------------|    |--------------------------|    | ---------- |
| ----------    ---------- |    | ----------    ---------- |    | |        | |
| |        |    |        | |    | |        |    |        | |    | | Orphan | |
| | VCPU_0 | .. | VCPU_N | |    | | VCPU_0 | .. | VCPU_K | |    | | VCPU_R | |
| |        |    |        | |    | |        |    |        | |    | |        | |
| ----------    ---------- | .. | ----------    ---------- |    | ---------- |
|--------------------------|    |--------------------------|    |      .     |
|       Address Space      |    |       Address Space      |    |      .     |
|---------- ------- -------|    |---------- ------- -------|    |      .     |
|| Memory | | PIC | | PIT ||    || Memory | | PIC | | PIT ||    | ---------- |
|---------- ------- -------|    |---------- ------- -------|    | |        | |
|----------------  --------|    |----------------  --------|    | | Orphan | |
|| Frame Buffer |  | UART ||    || Frame Buffer |  | UART ||    | | VCPU_0 | |
|----------------  --------|    |----------------  --------|    | |        | |
----------------------------    ----------------------------    | ---------- |
-----------------------------------------------------------------            |
|                                                                            |
|                 eXtensible Versatile hypervISOR (Xvisor)                   |
|                                                                            |
------------------------------------------------------------------------------
------------------------------------------------------------------------------
|                                                                            |
|            Host Machine (Host CPU + Host Memory + Host Devices)            |
|                                                                            |
------------------------------------------------------------------------------


	 	Chapter 2: Virtual CPU Scheduler

The VCPUs are a black box for Xvisor (i.e. any thing could be running on 
the VCPU) and exception/interrupt is the only way to entering to hypervisor 
mode when a VCPU is running directly on hardware, Hence our scheduler will 
always be invoked in exception/interrupt mode.

To simplfy context switching, we expect that the architecture specific 
exception/interrupt handler will save user register on interrupt stack and 
restore user registers from interrupt stack before interrupt return. Due to 
this simplification the user register context of current VCPU is available on
interrupt stack and saving/restoring user registers become simple memory 
copy operations.

To keep lower memory foot print, scheduler expects per host CPU interrupt 
stack in contrast to traditional UNIX systems which have per process 
interrupt/kernel stack. 

The VCPU scheduler use a round-robin strategy for fair share amoung VCPU, 
although VCPUs can have variable length time slices. Xvisor keeps track 
of time consumed by a VCPU through periodic calls to scheduler tick handler
(i.e. vmm_scheduler_tick()) from architecture specific code.

The possible scenarios in which a VCPU scheduler is invoked are:
  1. Just like any other OS, Xvisor also configures an architecture specific 
     timer interrupt. On every timer interrupt the architecture specific code 
     is expected to call scheduler tick handler (i.e. vmm_scheduler_tick()). 
     The tick handler invokes scheduler whenever time slice of a VCPU expires. 
     We call this situation as VCPU premption.
  2. If a VCPU misbehaves (i.e. does some invalid register/memory access) 
     then we get an exception/interrupt. The architecture specific code can 
     detect such situation and halt/pause the responsible VCPU. In this 
     situation the state of VCPU is changing in interrupt mode, hence we must 
     schedule some other VCPU which is runnable.
  3. The VCPU state can also be changed from some hypervisor thread or 
     managment terminal command. If the VCPU is already running when the state
     change occurs from a hypervisor thread  (can happen for SMP systems) then
     the state change will be reflected on next timer tick else the state 
     change will be reflected immediately.

In order to keep in track of VCPU state changes (by architecture specific code
or some hypervisor thread) and emulate interrupts for a VCPU, we must ensure 
that generic interrupt handler (i.e. vmm_scheduler_irq_process) is called at 
the end of every exception/interrupt.

The expected high-level steps involved in architecture specific 
exception/interrupt handler are:
  1. [Assembly] Switch stack to interrupt stack (if this is done automatically
     by hardware then skip this step)
  2. [Assembly] Save all user registers on interrupt stack
  3. [Assembly] Call the high-level c function with argument as pointer to 
     user registers on interrupt stack
  4. [C Code] If exception was generated by a host device then call host 
     interrupt subsystem to handle host device interrupt 
     (i.e. call vmm_host_irq_exec()) with following arguments:
     - cpu exception/interrupt number
     - pointer to user registers on interrupt stack
  5. [C Code] Do architecture specific processing for exception/interrupt.
  6. [C Code] Call generic interrupt handler (i.e. vmm_scheduler_irq_process) 
     with following arguments: 
     - pointer to user registers on interrupt stack
  7. [C Code] Return from high-level C function.
  8. [Assembly] Restore user registers from interrupt stack
  9. [Assembly] Do interrupt/exception return
(Note: To support nested interrupt/exception handler then modify the above 
steps such that generic interrupt handler (i.e. Step 6) is called only once 
in interrupt nesting).

The expected high-level steps involved in architecture specific VCPU context
switching (i.e. vmm_vcpu_regs_switch()) are as follows:
  1. Save user registers from stack (saved by architecture specific 
     exception/interrupt handler) to user registers of current VCPU 
     (i.e. 'uregs' of current VCPU).
  2. Restore user register of next VCPU (i.e. 'uregs' of current VCPU) to stack
     (will be restored by architecture specific exception/interrupt handler).
  3. Switch context of architecture specific CPU resources such as MMU, 
     Floating point subsystem, etc.
(Note: We don't need to save/restore supervisor registers because it is 
expected that whenever VCPU updates a supervisor register xvisor gets an 
exception. In the architecture specific code of exception handler we emulate 
the instruction updating supervisor register and keep the supervisor register 
of a VCPU in sync.)


	 	Chapter 3: Virtual CPU State Transitions

A VCPU can be in excatly one state at any give instance of time. Below is a 
brief description of all possible states:
  * UNKNOWN: VCPU does not belong to any Guest and is not Orphan VCPU. To 
    enforce lower memory foot print, we pre-allocate memory based on maximum 
    number of VCPUs and put them in this state.
  * RESET: VCPU is initialized and is waiting for someone to kick it to READY
    state. To create a new VCPU, the VCPU scheduler picks up a VCPU in UNKNOW 
    state from pre-allocated VCPUs and intialize it. After initialization the
    newly created VCPU is put in RESET state.
  * READY: VCPU is ready to run on hardware.
  * RUNNING: VCPU is currently running on hardware.
  * PAUSED: VCPU has been stopped and can resume later. A VCPU is set in this 
    state (usually by architecture specific code) when it detects that the VCPU
    is idle and can be scheduled out.
  * HALTED: VCPU has been stopped and cannot resume. A VCPU is set in this 
    state (usually by architecture specific code) when some errorneous access
    is done by that VCPU.

A VCPU state change can occur various locations such as architecture specific 
code, some hypervisor thread, scheduler, some emulated device, etc. Its not
possible to describe all possible VCPU state transtion scenarios but, the 
figures below can give a fair idea about it.

The figure below shows state transitions in a Normal VCPU.

                                           -----------
                               [Reset]     |         |      [Halt]     
                           ----------------|  HALTED |<------------------
                           |               |         |                  |
                           |               -----------                  |
                           |                    A                       |
                           |                    | [Halt]                |
                           V                    |                       |
----------- [Create]  -----------  [Kick]  ----------- [Scheduler] -----------
|         |---------->|         |--------->|         |------------>|         |
| UNKNOWN |           |  RESET  |          |  READY  |             | RUNNING |
|         |<----------|         |<---------|         |<------------|         |
----------- [Destroy] -----------  [Reset] ----------- [Scheduler] -----------
                        A     A              A     |                 |     |
                        |     |     [Resume] |     | [Pause]         |     |
                        |     |              |     V                 |     |
                        |     |            -----------               |     |
                        |     |            |         |               |     |
                        |     -------------|  PAUSED |<---------------     |
                        |        [Reset]   |         |   [Pause]           |
                        |                  -----------                     |
                        |                                                  |
                        ----------------------------------------------------
                                             [Reset]

The figure below shows state transitions in an Orphan VCPU.

----------- [Create]  ----------- [Scheduler] -----------
|         |---------->|         |------------>|         |
| UNKNOWN |           |  READY  |             | RUNNING |
|         |<----------|         |<------------|         |
----------- [Destroy] ----------- [Scheduler] -----------


	 	Chapter 4: Virtual CPU Interrupts

TBD.


	 	Chapter 5: Hypervisor Threads (Hyperthreads)

TBD.


